#!/usr/bin/env bash
#
# VIBECODING STACK - PRE-COMMIT HOOK
# ==================================
#
# Runs quality checks before allowing commits.
# Install: cp hooks/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit
#
# Checks:
# 1. No secrets or credentials in staged files
# 2. Format check (auto-fix available)
# 3. Lint check
# 4. Type check
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo_step() {
    echo -e "${BLUE}►${NC} $1"
}

echo_pass() {
    echo -e "${GREEN}✔${NC} $1"
}

echo_warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

echo_fail() {
    echo -e "${RED}✖${NC} $1"
}

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo_pass "No staged files to check"
    exit 0
fi

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
echo "║           VIBECODING PRE-COMMIT QUALITY CHECK              ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

ERRORS=0

# =============================================================================
# CHECK 1: SECRETS DETECTION
# =============================================================================

echo_step "Checking for secrets and credentials..."

SECRET_PATTERNS=(
    'password\s*[:=]\s*["\x27][^"\x27]+["\x27]'
    'api[_-]?key\s*[:=]\s*["\x27][^"\x27]+["\x27]'
    'secret\s*[:=]\s*["\x27][^"\x27]+["\x27]'
    'token\s*[:=]\s*["\x27][a-zA-Z0-9_-]{20,}["\x27]'
    'AWS_ACCESS_KEY_ID\s*[:=]'
    'AWS_SECRET_ACCESS_KEY\s*[:=]'
    'PRIVATE[_-]KEY'
    'BEGIN RSA PRIVATE KEY'
    'BEGIN OPENSSH PRIVATE KEY'
    'sk-[a-zA-Z0-9]{48}'  # OpenAI API key pattern
    'sk-ant-[a-zA-Z0-9-]{90,}'  # Anthropic API key pattern
    'ghp_[a-zA-Z0-9]{36}'  # GitHub personal access token
    'gho_[a-zA-Z0-9]{36}'  # GitHub OAuth token
    'glpat-[a-zA-Z0-9-]{20}'  # GitLab personal access token
)

SECRET_FOUND=0
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        # Skip files that commonly contain credential templates/patterns (not actual secrets)
        if echo "$file" | grep -qE '\.(md|txt|example|sample|template)$|vibecode$|setup\.sh$|install\.sh$|hooks/'; then
            continue
        fi
        for pattern in "${SECRET_PATTERNS[@]}"; do
            if grep -qEi "$pattern" "$file" 2>/dev/null; then
                echo_fail "Potential secret found in $file"
                echo "    Pattern: $pattern"
                SECRET_FOUND=1
            fi
        done
    fi
done

if [ $SECRET_FOUND -eq 1 ]; then
    echo ""
    echo_fail "BLOCKED: Potential secrets detected in staged files"
    echo "    Remove secrets before committing or add to .gitignore"
    echo "    Use environment variables for sensitive values"
    echo ""
    ERRORS=$((ERRORS + 1))
else
    echo_pass "No secrets detected"
fi

# =============================================================================
# CHECK 2: FILE-SPECIFIC CHECKS
# =============================================================================

# Get file types
JS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' || true)
PY_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)
GO_FILES=$(echo "$STAGED_FILES" | grep -E '\.go$' || true)
JSON_FILES=$(echo "$STAGED_FILES" | grep -E '\.json$' || true)

# =============================================================================
# CHECK 3: FORMAT CHECK
# =============================================================================

echo_step "Checking code formatting..."

FORMAT_ERRORS=0

# JavaScript/TypeScript
if [ -n "$JS_FILES" ]; then
    if command -v npx &> /dev/null && [ -f "package.json" ]; then
        if ! npx prettier --check $JS_FILES 2>/dev/null; then
            echo_warn "JS/TS files need formatting"
            echo "    Run: npx prettier --write $JS_FILES"
            FORMAT_ERRORS=1
        fi
    fi
fi

# Python
if [ -n "$PY_FILES" ]; then
    if command -v black &> /dev/null; then
        if ! black --check $PY_FILES 2>/dev/null; then
            echo_warn "Python files need formatting"
            echo "    Run: black $PY_FILES"
            FORMAT_ERRORS=1
        fi
    elif command -v ruff &> /dev/null; then
        if ! ruff format --check $PY_FILES 2>/dev/null; then
            echo_warn "Python files need formatting"
            echo "    Run: ruff format $PY_FILES"
            FORMAT_ERRORS=1
        fi
    fi
fi

# Go
if [ -n "$GO_FILES" ]; then
    GOFMT_OUTPUT=$(gofmt -l $GO_FILES 2>/dev/null)
    if [ -n "$GOFMT_OUTPUT" ]; then
        echo_warn "Go files need formatting: $GOFMT_OUTPUT"
        echo "    Run: gofmt -w $GO_FILES"
        FORMAT_ERRORS=1
    fi
fi

# JSON
if [ -n "$JSON_FILES" ]; then
    for file in $JSON_FILES; do
        if [ -f "$file" ]; then
            if ! python3 -c "import json; json.load(open('$file'))" 2>/dev/null; then
                echo_fail "Invalid JSON: $file"
                FORMAT_ERRORS=1
            fi
        fi
    done
fi

if [ $FORMAT_ERRORS -eq 0 ]; then
    echo_pass "Formatting check passed"
else
    # Offer auto-fix
    echo ""
    read -p "Auto-fix formatting issues? [y/N] " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo_step "Auto-fixing formatting..."
        
        if [ -n "$JS_FILES" ]; then
            npx prettier --write $JS_FILES 2>/dev/null || true
        fi
        if [ -n "$PY_FILES" ]; then
            black $PY_FILES 2>/dev/null || ruff format $PY_FILES 2>/dev/null || true
        fi
        if [ -n "$GO_FILES" ]; then
            gofmt -w $GO_FILES 2>/dev/null || true
        fi
        
        # Re-stage fixed files
        git add $STAGED_FILES
        echo_pass "Formatting fixed and re-staged"
    else
        ERRORS=$((ERRORS + 1))
    fi
fi

# =============================================================================
# CHECK 4: LINT CHECK
# =============================================================================

echo_step "Running linter..."

LINT_ERRORS=0

# JavaScript/TypeScript
if [ -n "$JS_FILES" ]; then
    if [ -f "package.json" ] && grep -q '"lint"' package.json 2>/dev/null; then
        if ! npm run lint -- --quiet 2>/dev/null; then
            echo_warn "ESLint errors found"
            LINT_ERRORS=1
        fi
    elif command -v npx &> /dev/null; then
        if ! npx eslint --quiet $JS_FILES 2>/dev/null; then
            echo_warn "ESLint errors found"
            LINT_ERRORS=1
        fi
    fi
fi

# Python
if [ -n "$PY_FILES" ]; then
    if command -v ruff &> /dev/null; then
        if ! ruff check $PY_FILES 2>/dev/null; then
            echo_warn "Ruff errors found"
            LINT_ERRORS=1
        fi
    elif command -v pylint &> /dev/null; then
        if ! pylint --errors-only $PY_FILES 2>/dev/null; then
            echo_warn "Pylint errors found"
            LINT_ERRORS=1
        fi
    fi
fi

# Go
if [ -n "$GO_FILES" ]; then
    if ! go vet ./... 2>/dev/null; then
        echo_warn "Go vet found issues"
        LINT_ERRORS=1
    fi
fi

if [ $LINT_ERRORS -eq 0 ]; then
    echo_pass "Lint check passed"
else
    echo_warn "Lint issues found (continuing anyway)"
fi

# =============================================================================
# CHECK 5: TYPE CHECK
# =============================================================================

echo_step "Running type check..."

TYPE_ERRORS=0

# TypeScript
if [ -n "$JS_FILES" ] && [ -f "tsconfig.json" ]; then
    if ! npx tsc --noEmit 2>/dev/null; then
        echo_warn "TypeScript errors found"
        TYPE_ERRORS=1
    fi
fi

# Python
if [ -n "$PY_FILES" ]; then
    if command -v mypy &> /dev/null; then
        if ! mypy --ignore-missing-imports $PY_FILES 2>/dev/null; then
            echo_warn "Mypy errors found"
            TYPE_ERRORS=1
        fi
    fi
fi

if [ $TYPE_ERRORS -eq 0 ]; then
    echo_pass "Type check passed"
else
    echo_warn "Type issues found (continuing anyway)"
fi

# =============================================================================
# SUMMARY
# =============================================================================

echo ""
echo "════════════════════════════════════════════════════════════"

if [ $ERRORS -gt 0 ]; then
    echo_fail "PRE-COMMIT CHECK FAILED"
    echo ""
    echo "Fix the issues above before committing."
    echo "To bypass (not recommended): git commit --no-verify"
    echo ""
    exit 1
else
    echo_pass "PRE-COMMIT CHECK PASSED"
    echo ""
    exit 0
fi
